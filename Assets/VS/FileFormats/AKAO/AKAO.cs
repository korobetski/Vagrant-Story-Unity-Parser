using FileFormats;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
using VS.Core;
using VS.Utils;

namespace VS.FileFormats.AKAO
{
    public class AKAO:ScriptableObject
    {
        public Enums.AKAO.Type type;


        public static bool CheckHeader(byte[] bytes)
        {
            //41 4B 41 4F
            return (bytes[0] == 0x41 && bytes[1] == 0x4B && bytes[2] == 0x41 && bytes[3] == 0x4F) ? true : false;
        }

        public static List<AKAOSampleCollection> GetAKAOSampleCollections(AKAOSequence sequence, List<byte> A1PC)
        {
            // we must gather all needed sample collections, WAVE005.DAT + one other in most of cases
            // WAVE0000 startingArticulationId = 0
            // WAVE0005 startingArticulationId = 32
            // WAVE0032 startingArticulationId = 32
            //  others  startingArticulationId = 64    articulation length can be 32 or 64
            // WAVE0200 startingArticulationId = 128


            List<AKAOSampleCollection> sampleCollections = new List<AKAOSampleCollection>();
            string zz = "0";
            if (sequence.sampleCollectionId < 100) zz += "0";
            if (sequence.sampleCollectionId < 10) zz += "0";
            string sampleCollectionName = "WAVE" + zz + sequence.sampleCollectionId;
            List<string> collectionNames = new List<string>() { "WAVE0000", "WAVE0005", sampleCollectionName, "WAVE0091", "WAVE0200" }; // i use WAVE0091 but its random


            for (int i = 0; i < collectionNames.Count; i++)
            {
                AKAOSampleCollection serializedCollection = Resources.Load<AKAOSampleCollection>(string.Concat("Serialized/AKAO/SampleCollections/", collectionNames[i], ".yaml.asset"));
                if (serializedCollection == null)
                {
                    // Corresponding serialized AKAOSampleCollection not found, so we try to serialize
                    VSPConfig conf = Memory.LoadConfig();
                    string ascFilePath = string.Concat(conf.VSPath, "SOUND/", collectionNames[i], ".DAT");
                    serializedCollection = ScriptableObject.CreateInstance<AKAOSampleCollection>();
                    serializedCollection.ParseFromFile(ascFilePath);

                    ToolBox.SaveScriptableObject("Assets/Resources/Serialized/AKAO/SampleCollections/", collectionNames[i] + ".yaml.asset", serializedCollection);
                }
                sampleCollections.Add(serializedCollection);
            }

            if (A1PC.Count > 0)
            {
                // we need to add new instruments with an unique region
                foreach (byte art in A1PC)
                {
                    AKAOInstrument A1Instrument = new AKAOInstrument(art);
                    A1Instrument.name = "Articulation #" + (ushort)art;
                    A1Instrument.a1 = true;
                    A1Instrument.regions = new AKAORegion[1];
                    AKAORegion defaultRegion = new AKAORegion();
                    defaultRegion.articulationId = art;
                    A1Instrument.regions[0] = defaultRegion;
                    List<AKAOInstrument> _instr = (sequence.instruments == null) ? new List<AKAOInstrument>() : new List<AKAOInstrument>(sequence.instruments);
                    _instr.Add(A1Instrument);
                    sequence.instruments = _instr.ToArray();
                }
            }


            return sampleCollections;
        }

        public static void BuildSoundFont(AKAOSequence sequencer, List<AKAOSampleCollection> sampleCollections)
        {
            // we need both AKAOSequence and AKAOSampleCollections to build a SF2 file
            // because Instruments & Regions are set in Sequences
            // when Articulations & Samples are set in SampleCollections
            SF2 sf2 = new SF2();
            sf2.InfoChunk.Bank = "Vagrant Story SoundFont for " + sequencer.Filename;
            sf2.InfoChunk.Products = "Vagrant Story";
            sf2.InfoChunk.Tools = "https://github.com/korobetski/Vagrant-Story-Unity-Parser";
            sf2.InfoChunk.Designer = "Korobetski Sigfrid";
            sf2.InfoChunk.Date = DateTime.Now.ToString();
            sf2.InfoChunk.Copyright = "Musics & Samples belong to Hitoshi Sakimoto @ Squaresoft";
            sf2.InfoChunk.Comment = string.Concat("This SoundFont was generated by reading raw AKAO format from the original game in SOUND folder.\r",
            "\nNever forget that musics and samples belongs to SquareEnix, don't use them as your own. Sample collections : ",
            sampleCollections[0].Filename, ", ",
            sampleCollections[1].Filename, ", ",
            sampleCollections[2].Filename, ", ",
            sampleCollections[3].Filename, ", ",
            sampleCollections[4].Filename);

            List<AKAOSample> Samples = new List<AKAOSample>();

            // MUSIC024.DAT has no instruments Oo, maybe unfinished work, or development test
            // we use composer program change to load articulations from WAVE000.DAT the only file where start id = 0
            List<byte> prgs = sequencer.programs;
            if (sequencer.instruments == null)
            {
                foreach (byte id in sequencer.programs)
                {
                    AKAOInstrument instrument = new AKAOInstrument(id);
                    instrument.name = "No instrument " + id;
                    instrument.regions = new AKAORegion[1];
                    AKAORegion defaultRegion = new AKAORegion();
                    defaultRegion.articulationId = (byte)id;
                    instrument.regions[0] = defaultRegion;
                    sequencer.instruments = new AKAOInstrument[] { instrument };
                }
            }

            if (sequencer.instruments != null)
            {
                uint i = 0;
                foreach (AKAOInstrument instrument in sequencer.instruments)
                {
                    if (prgs.Contains(instrument.program) || instrument.isDrum)
                    {
                        if (instrument.isDrum)
                        {
                            sf2.AddPreset(instrument.name, 0, 128);
                        }
                        else
                        {
                            sf2.AddPreset(instrument.name, (ushort)instrument.program, 0);
                        }

                        sf2.AddPresetBag();
                        sf2.AddPresetGenerator(SF2Generator.ReverbEffectsSend, new SF2GeneratorAmount { UAmount = (ushort)1000 });
                        sf2.AddPresetGenerator(SF2Generator.Instrument, new SF2GeneratorAmount { UAmount = (ushort)i });
                        sf2.AddInstrument(instrument.name);
                        i++;

                        if (instrument.regions.Length > 0)
                        {
                            foreach (AKAORegion region in instrument.regions)
                            {
                                AKAOArticulation articulation = null;
                                AKAOSampleCollection coll = sampleCollections[2];

                                if (region.articulationId >= 0 && region.articulationId < 32)
                                {
                                    coll = sampleCollections[0];
                                    articulation = coll.articulations[region.articulationId];
                                }
                                else if (region.articulationId >= 32 && region.articulationId < 64)
                                {
                                    coll = sampleCollections[1];
                                    articulation = coll.articulations[region.articulationId - coll.startingArticulationId];
                                }
                                else if (region.articulationId >= 64 && region.articulationId < 128)
                                {
                                    coll = sampleCollections[2];
                                    if (region.articulationId - coll.startingArticulationId < coll.articulations.Length/* && !instrument.a1*/)
                                    {
                                        articulation = coll.articulations[region.articulationId - coll.startingArticulationId];
                                    }
                                    else
                                    {
                                        coll = sampleCollections[3];
                                        articulation = coll.articulations[region.articulationId - coll.startingArticulationId];

                                    }
                                }
                                else if (region.articulationId >= 128)
                                {
                                    coll = sampleCollections[4];
                                    articulation = coll.articulations[region.articulationId - coll.startingArticulationId];
                                }

                                if (articulation != null)
                                {
                                    articulation.BuildADSR();
                                    //region.articulation = articulation;
                                    AKAOSample sample = coll.samples[articulation.sampleId];

                                    uint unityKey;
                                    short fineTune;

                                    if (instrument.isDrum)
                                    {
                                        unityKey = (uint)articulation.unityKey + region.lowKey - region.relativeKey; // maybe
                                    }
                                    else
                                    {
                                        unityKey = articulation.unityKey;
                                    }

                                    short ft = articulation.fineTune;
                                    if (ft < 0)
                                    {
                                        ft += short.MaxValue;
                                    }

                                    double freq_multiplier = ((ft * 32) + 0x100000) / (double)0x100000;
                                    double cents = (short)(1200 * Math.Log(freq_multiplier, 2));
                                    if (articulation.fineTune < 0)
                                    {
                                        cents -= 1200;
                                    }

                                    fineTune = (short)cents;
                                    sample.loopStart = (uint)(articulation.loopPt * 1.75);
                                    sample.unityKey = articulation.unityKey;

                                    if (!Samples.Contains(sample))
                                    {
                                        Samples.Add(sample);
                                    }

                                    int sampleIDX = Samples.IndexOf(sample);


                                    // http://linuxmao.org/SoundFont+specification+SF2
                                    sf2.AddInstrumentBag();
                                    sf2.AddInstrumentGenerator(SF2Generator.KeyRange, new SF2GeneratorAmount { LowByte = region.lowKey, HighByte = region.hiKey });
                                    //sf2.AddInstrumentGenerator(SF2Generator.VelRange, new SF2GeneratorAmount { LowByte = region.lowVel, HighByte = region.hiVel }); // not sure
                                    sf2.AddInstrumentGenerator(SF2Generator.VelRange, new SF2GeneratorAmount { LowByte = 0, HighByte = 127 });
                                    /* C'est l'atténuation, en centibels, pour laquelle une note est atténuée en dessous de la valeur maximum prévue.
                                    Si = 0, il n'y a aucune atténuation, la note sera jouée au maximum prévu.
                                    Ex : 60 indique que la note sera jouée à 6 dB en-dessous du maximum prévu pour la note.
                                    Max value = 1440 */
                                    sf2.AddInstrumentGenerator(SF2Generator.InitialAttenuation, new SF2GeneratorAmount { UAmount = (ushort)(region.attenuation * 11) });
                                    //sf2.AddInstrumentGenerator(SF2Generator.ReverbEffectsSend, new SF2GeneratorAmount { Amount = 1000 });
                                    sf2.AddInstrumentGenerator(SF2Generator.Pan, new SF2GeneratorAmount { Amount = region.pan });
                                    sf2.AddInstrumentGenerator(SF2Generator.SampleModes, new SF2GeneratorAmount { UAmount = (articulation.loopPt != 0) ? (ushort)1 : (ushort)0 });
                                    sf2.AddInstrumentGenerator(SF2Generator.OverridingRootKey, new SF2GeneratorAmount { UAmount = (ushort)unityKey });

                                    sf2.AddInstrumentGenerator(SF2Generator.DelayVolEnv, new SF2GeneratorAmount { Amount = (short)short.MinValue });
                                    /* En timecents absolu, c'est la durée, depuis la fin du délai de l'enveloppe de volume jusqu'au point où la valeur de l'enveloppe de volume atteint son apogée.
                                    Une valeur de 0 indique 1 seconde. Une valeur négative indique un temps inférieur à une seconde, une valeur positive un temps supérieur à une seconde.
                                    Le nombre le plus négatif (-32768) indique conventionnellement une attaque instantanée.
                                    Ex : un temps d'attaque de 10 ms serait 1200log2 (.01) = -7973.
                                    En musique, le logarithme binaire intervient dans la formule permettant de déterminer la valeur en cents d’un intervalle.
                                    Un cent, ou centième de demi-ton au tempérament égal, vaut 1200 fois le logarithme binaire du rapport de fréquence des sons concernés.
                                    546 * 60 ~= short.MaxValue */
                                    sf2.AddInstrumentGenerator(SF2Generator.AttackVolEnv, new SF2GeneratorAmount { Amount = (short)(1200 * Math.Log(articulation.A, 2)) });
                                    sf2.AddInstrumentGenerator(SF2Generator.HoldVolEnv, new SF2GeneratorAmount { Amount = (short)0 });
                                    /* C'est le temps, en timecents absolus, pour une variation de 100% de la valeur de l'enveloppe du volume pendant la phase de décroissance.
                                    Pour l'enveloppe de volume, la décroissance tend linéairement vers le niveau de maintien, ce qui provoque un changement de dB constant pour chaque unité de temps.
                                    Si le niveau de maintien = -100dB, le temps de décroissance de l'enveloppe de volume = temps de la phase de décroissance.
                                    Une valeur de 0 indique 1 seconde de temps de décroissance pour un niveau zéro. Une valeur négative indique un temps inférieur à une seconde,
                                    une valeur positive un temps supérieur à une seconde.
                                    Ex : un temps de décroissance de 10 msec serait 1200log2 (.01) = -7973.*/
                                    sf2.AddInstrumentGenerator(SF2Generator.DecayVolEnv, new SF2GeneratorAmount { Amount = (short)(1200 * Math.Log(articulation.D, 2)) });
                                    /* C'est le taux de la diminution, exprimé en centibels, pour laquelle l'enveloppe de volume décroît au cours de la phase de décroissance.
                                    Pour l'enveloppe de volume, le niveau d'atténuation du sustain est mieux exprimé en centibels. Une valeur de 0 indique que le niveau est maximum.
                                    Une valeur positive indique une décroissance au niveau correspondant. Les valeurs inférieures à zéro doivent être interprétés comme zéro;
                                    conventionnellement 1000 indique une atténuation complète.
                                    Ex : un niveau de soutien qui correspond à une valeur absolue de 12 dB en dessous du pic serait 120.*/
                                    sf2.AddInstrumentGenerator(SF2Generator.SustainVolEnv, new SF2GeneratorAmount { Amount = (short)(articulation.S) });
                                    /* C'est la durée, en timecents absolu, pour une variation de 100% de la valeur de l'enveloppe du volume pendant la phase de libération (release).
                                    Pour l'enveloppe de volume, la phase de libération tend linéairement vers zéro depuis la niveau en cours,
                                    ce qui provoque un changement en dB constant pour chaque unité de temps.
                                    Si le niveau actuel est maximum, la durée du release de l'enveloppe de volume sera le temps de libération jusqu'à ce que 100 dB d'atténuation soit atteint.
                                    Une valeur de 0 indique 1 seconde de temps de décroissance pour finir complètement. Une valeur négative indique un temps inférieur à une seconde,
                                    une valeur positive un temps de plus d'une seconde.
                                    Ex : un temps de libération de 10 msec serait 1200log2 (.01) = -7973. */
                                    sf2.AddInstrumentGenerator(SF2Generator.ReleaseVolEnv, new SF2GeneratorAmount { Amount = (short)(1200 * Math.Log(articulation.R, 2)) });
                                    /* Décalage de la hauteur, en cents, qui sera appliqué à la note.
                                    Il est additionnel à coarseTune. Une valeur positive indique que le son est reproduit à une hauteur plus élevée, une valeur négative indique une hauteur inférieure.
                                    Ex : une valeur finetune = -5 provoquera un son joué cinq cents plus bas. */
                                    sf2.AddInstrumentGenerator(SF2Generator.FineTune, new SF2GeneratorAmount { Amount = (short)(fineTune) });
                                    sf2.AddInstrumentGenerator(SF2Generator.SampleID, new SF2GeneratorAmount { UAmount = (ushort)sampleIDX });
                                }

                            }
                        }

                    }
                }
            }

            if (Samples.Count > 0)
            {
                foreach (AKAOSample AKAOsmp in Samples)
                {
                    WAV nw = AKAOsmp.ConvertToWAV();
                    nw.SetName(AKAOsmp.name);
                    nw.Riff = false;

                    short[] pcm = AKAOsmp.WAVDatas.ToArray();
                    sf2.AddSample(pcm, AKAOsmp.name, (AKAOsmp.loopStart > 0), AKAOsmp.loopStart, 44100, (byte)AKAOsmp.unityKey, 0);
                }
            }
            ToolBox.DirExNorCreate("Assets/SF2/");
            sf2.Save("Assets/SF2/" + sequencer.Filename + ".sf2");

        }
    }
}
